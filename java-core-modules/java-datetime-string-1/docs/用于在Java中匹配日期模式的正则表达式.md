## 1. 概述

如果使用得当，正则表达式是匹配各种模式的强大工具。

在本文中，我们将使用java.util.regex包来确定给定的字符串是否包含有效日期。

有关正则表达式的介绍，请参阅[我们的Java正则表达式 API 指南](https://www.baeldung.com/regular-expressions-java)。

## 2. 日期格式概述

我们将定义一个与国际公历相关的有效日期。我们的格式将遵循一般模式：YYYY-MM-DD。

我们还包括闰年的概念，闰年是包含 2 月 29 日这一天的年份。根据公历，除了能被100整除的年份，但包括能被400整除的年份，如果年份数能被4整除，我们就称这一年为闰年。

在所有其他情况下，我们称一年为正常年。

有效日期示例：

-   2017-12-31
-   2020-02-29
-   2400-02-29

无效日期示例：

-   2017/12/31：不正确的令牌定界符
-   2018-1-1：缺少前导零
-   2018-04-31：错误的四月天数
-   2100-02-29：今年不是飞跃，因为该值除以100，因此 2 月限制为 28 天

## 3. 实施解决方案

由于我们要使用正则表达式匹配日期，因此让我们首先画出一个接口DateMatcher，它提供一个matches方法：

```java
public interface DateMatcher {
    boolean matches(String date);
}
```

我们将在下面逐步介绍实施，以最终形成完整的解决方案。

### 3.1. 匹配广泛的格式

我们将从创建一个非常简单的原型开始处理我们的匹配器的格式约束：

```java
class FormattedDateMatcher implements DateMatcher {

    private static Pattern DATE_PATTERN = Pattern.compile(
      "^d{4}-d{2}-d{2}$");

    @Override
    public boolean matches(String date) {
        return DATE_PATTERN.matcher(date).matches();
    }
}
```

这里我们指定有效日期必须由三组整数组成，并用破折号分隔。第一组由四个整数组成，其余两组各有两个整数。

配对日期：2017-12-31、2018-01-31、0000-00-00、1029-99-72 _ _ _ _

不匹配日期：2018-01、2018-01 -XX、 2020/02 / 29

### 3.2. 匹配特定的日期格式

我们的第二个示例接受日期标记的范围以及我们的格式约束。为简单起见，我们将兴趣限制在 1900 年至 2999 年之间。

现在我们成功地匹配了我们的通用日期格式，我们需要进一步限制它——以确保日期实际上是正确的：

```java
^((19|2[0-9])[0-9]{2})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$
```

这里我们介绍了三组需要匹配的整数范围：

-   `(19|2[0-9])[0-9]{2}`通过匹配以19或2X开头后跟任意数字的数字来涵盖有限的年份范围。
-   `0[1-9]|1[012]`匹配01-12范围内的月份数
-   `0[1-9]|[12][0-9]|3[01]`匹配01-31范围内的天数

配对日期：1900-01-01、2205-02-31、2999-12-31 _ _

不匹配日期：1899-12-31、2018-05-35、2018-13-05、3000-01-01、2018-01 - XX _ _ _

### 3.3. 匹配 2 月 29 日

为了正确匹配闰年，我们必须首先确定遇到闰年的时间，然后确保我们接受 2 月 29 日作为这些年份的有效日期。

由于我们限制范围内的闰年数量足够大，我们应该使用适当的整除规则来过滤它们：

-   如果一个数的最后两位数能被4整除，则原数能被4整除
-   如果数字的最后两位是 00，则该数字可以被 100 整除

这是一个解决方案：

```java
^((2000|2400|2800|(19|2[0-9])(0[48]|[2468][048]|[13579][26]))-02-29)$
```

该模式由以下部分组成：

-   `2000|2400|2800`在1900-2999的限制范围内匹配一组闰年，分隔符为400
-   `19|2[0-9](0[48]|[2468][048]|[13579][26]))`匹配除数为4且不为100的年份的所有白名单组合
-   `-02-29`2月2日比赛

配对日期：2020-02-29 , 2024-02-29 , 2400-02-29

不匹配日期：2019-02-29、2100-02-29、3200-02-29、2020 / 02 / 29

### 3.4. 匹配二月的一般日子

除了匹配闰年的 2 月 29 日，我们还需要匹配所有年份中 2 月 (1 – 28) 的所有其他日期：

```java
^(((19|2[0-9])[0-9]{2})-02-(0[1-9]|1[0-9]|2[0-8]))$
```

配对日期：2018-02-01、2019-02-13、2020-02-25 _ _

不匹配日期：2000-02-30、2400-02-62、2018 / 02 / 28

### 3.5. 匹配 31 天的月份

一月、三月、五月、七月、八月、十月和十二月应该匹配 1 到 31 天：

```java
^(((19|2[0-9])[0-9]{2})-(0[13578]|10|12)-(0[1-9]|[12][0-9]|3[01]))$
```

配对日期：2018-01-31、2021-07-31、2022-08-31 _ _

不匹配日期：2018-01-32、2019-03-64、2018 / 01 / 31

### 3.6. 匹配 30 天的月份

4 月、6 月、9 月和 11 月应该匹配 1 到 30 天：

```java
^(((19|2[0-9])[0-9]{2})-(0[469]|11)-(0[1-9]|[12][0-9]|30))$
```

配对日期：2018-04-30、2019-06-30、2020-09-30 _ _

不匹配日期：2018-04-31、2019-06-31、2018 / 04 / 30

### 3.7. 公历日期匹配器

现在我们可以将上面的所有模式组合成一个匹配器，以获得满足所有约束的完整GregorianDateMatcher ：

```java
class GregorianDateMatcher implements DateMatcher {

    private static Pattern DATE_PATTERN = Pattern.compile(
      "^((2000|2400|2800|(19|2[0-9])(0[48]|[2468][048]|[13579][26]))-02-29)$" 
      + "|^(((19|2[0-9])[0-9]{2})-02-(0[1-9]|1[0-9]|2[0-8]))$"
      + "|^(((19|2[0-9])[0-9]{2})-(0[13578]|10|12)-(0[1-9]|[12][0-9]|3[01]))$" 
      + "|^(((19|2[0-9])[0-9]{2})-(0[469]|11)-(0[1-9]|[12][0-9]|30))$");

    @Override
    public boolean matches(String date) {
        return DATE_PATTERN.matcher(date).matches();
    }
}
```

我们使用了交替字符“|” 匹配四个分支中的至少一个。因此，二月的有效日期要么匹配闰年 2 月 29 日的第一个分支，要么匹配从1到28的任何一天的第二个分支。剩余月份的日期与第三个和第四个分支匹配。

由于我们尚未优化此模式以提高可读性，请随意尝试一段长度。

此时我们已经满足了我们在开始时介绍的所有约束。

### 3.8. 性能说明

解析复杂的正则表达式可能会显着影响执行流程的性能。本文的主要目的不是学习一种有效的方法来测试字符串在一组所有可能日期中的成员资格。

如果需要一种可靠且快速的方法来验证日期，请考虑使用Java8 提供的LocalDate.parse() 。

## 4。总结

在本文中，我们通过提供格式、范围和月份长度的规则，学习了如何使用正则表达式来匹配严格格式化的公历日期。