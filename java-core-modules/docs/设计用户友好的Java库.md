## 一、概述

Java 是开源世界的支柱之一。几乎每个 Java 项目都使用其他开源项目，因为没有人愿意重新发明轮子。然而，很多时候我们需要一个库来实现它的功能，但我们不知道如何使用它。我们遇到这样的事情：

-   所有这些“*服务”类是什么？
-   我如何实例化它，它需要太多的依赖。什么是“*闩锁*”？
-   哦，我把它放在一起，但现在它开始抛出*IllegalStateException*。我究竟做错了什么？

问题在于，并非所有的图书馆设计者都为他们的用户着想。大多数人只考虑功能和特性，但很少有人考虑 API 将如何在实践中使用，以及用户代码的外观和测试方式。

这篇文章附带了一些关于如何让我们的用户免于这些挣扎的建议——不，这不是通过编写文档。当然，关于这个主题可以写一整本书（而且已经有几本书）；这些是我自己在几个库中工作时学到的一些关键点。

我将使用两个库来举例说明这些想法：[charles](https://www.github.com/opencharles/charles)和[jcabi-github](https://www.github.com/jcabi/jcabi-github)

## 2. 边界

这应该是显而易见的，但很多时候并非如此。在开始编写任何一行代码之前，我们需要明确回答一些问题：需要哪些输入？我的用户将看到的第一类是什么？我们需要用户的任何实现吗？输出是什么？一旦清楚地回答了这些问题，一切都会变得容易，因为图书馆已经有了衬里，有了形状。

### **2.1. 输入**

这可能是最重要的话题。我们必须确保清楚用户需要向图书馆提供什么才能使其正常工作。在某些情况下，这是一件非常微不足道的事情：它可能只是一个表示 API 的身份验证令牌的字符串，但它也可能是一个接口或抽象类的实现。

一个很好的做法是通过构造函数获取所有依赖项，并使用一些参数保持简短。如果我们需要一个包含三个或四个以上参数的构造函数，那么显然应该重构代码。如果使用方法来注入强制依赖项，那么用户很可能会遇到概述中描述的第三种挫败感。

此外，我们应该始终提供不止一种构造函数，为用户提供替代方案。让他们同时使用*String*和*Integer*或者不要将它们限制为*FileInputStream*，使用*InputStream*，这样他们就可以在单元测试等时提交*ByteArrayInputStream 。*

例如，这里有几种我们可以使用 jcabi-github 实例化 Github API 入口点的方法：

```java
Github noauth = new RtGithub();
Github basicauth = new RtGithub("username", "password");
Github oauth = new RtGithub("token");
复制
```

简单，没有喧嚣，没有可疑的配置对象来初始化。拥有这三个构造函数是有意义的，因为您可以在注销、登录或应用程序可以代表您进行身份验证的情况下使用 Github 网站。当然，如果您未通过身份验证，某些功能将无法使用，但您从一开始就知道这一点。

作为第二个例子，这里是我们如何使用 charles，一个网络爬虫库：

```java
WebDriver driver = new FirefoxDriver();
Repository repo = new InMemoryRepository();
String indexPage = "http://www.amihaiemil.com/index.html";
WebCrawl graph = new GraphCrawl(
  indexPage, driver, new IgnoredPatterns(), repo
);
graph.crawl();
复制
```

我相信这也是不言自明的。然而，在写这篇文章时，我意识到在当前版本中存在一个错误：所有构造函数都要求用户提供*IgnoredPatterns*的实例。默认情况下，不应忽略任何模式，但用户不必指定这一点。我决定在这里保留它，所以你会看到一个反例。*我假设您会尝试实例化 WebCrawl 并想知道“那个IgnoredPatterns*是什么？！”

变量 indexPage 是开始抓取的 URL，driver 是要使用的浏览器（不能默认为任何内容，因为我们不知道运行的机器上安装了哪个浏览器）。repo 变量将在下一节中解释。

因此，正如您在示例中看到的那样，尽量保持简单、直观和不言自明。以用户在查看您的构造函数时不会挠头的方式封装逻辑和依赖项。

如果您仍然有疑问，请尝试使用[aws-sdk-java](https://github.com/aws/aws-sdk-java)向 AWS 发出 HTTP请求：您将不得不处理所谓的 AmazonHttpClient，它在某处使用 ClientConfiguration，然后需要在两者之间的某处获取 ExecutionContext。最后，您可能会执行您的请求并获得响应，但仍然不知道 ExecutionContext 是什么，例如。

### **2.2. 输出**

这主要用于与外部世界通信的图书馆。在这里我们应该回答“如何处理输出？”这个问题。同样，这是一个相当有趣的问题，但很容易出错。

再看看上面的代码。为什么我们必须提供一个 Repository 实现？为什么 WebCrawl.crawl() 方法不只返回一个网页元素列表？处理爬取的页面显然不是图书馆的工作。它怎么知道我们想用它们做什么？是这样的：

```java
WebCrawl graph = new GraphCrawl(...);
List<WebPage> pages = graph.crawl();
复制
```

没有比这更糟的了。如果被抓取的站点碰巧有 1000 个页面，则可能会突然出现 OutOfMemory 异常 - 库将它们全部加载到内存中。有两种解决方案：

-   继续返回页面，但实施某种分页机制，用户必须在其中提供开始和结束编号。或者
-   要求用户使用名为 export(List<WebPage>) 的方法实现一个接口，每次达到最大页数时算法都会调用该接口

第二种选择是迄今为止最好的；它使双方的事情都变得更简单，并且更易于测试。想一想如果我们采用第一种方法，需要在用户端实现多少逻辑。像这样，指定页面的存储库（将它们发送到数据库中或将它们写入磁盘）并且在调用方法 crawl() 之后无需执行任何其他操作。

顺便说一句，上面输入部分的代码是我们为了获取网站内容而必须编写的所有代码（仍然在内存中，正如 repo 实现所说，但这是我们的选择——我们提供了该实现我们承担风险）。

总结本节：我们永远不应该将我们的工作与客户的工作完全分开。我们应该始终思考我们创建的输出会发生什么。就像卡车司机应该帮助打开货物包装，而不是在到达目的地后简单地将它们扔掉。

## 3.接口

始终使用接口。用户应仅通过严格的合同与我们的代码进行交互。

例如，在*jcabi-github*库中，类 RtGithub 是用户实际看到的唯一一个：

```java
Repo repo = new RtGithub("oauth_token").repos().get(
  new Coordinates.Simple("eugenp/tutorials"));
Issue issue = repo.issues()
  .create("Example issue", "Created with jcabi-github");复制
```

上面的代码片段在[eugenp/tutorials repo](https://github.com/eugenp/tutorials)中创建了一个票证。使用了 Repo 和 Issue 的实例，但从未透露实际类型。我们不能这样做：

```java
Repo repo = new RtRepo(...)复制
```

出于合乎逻辑的原因，上述情况是不可能的：我们不能直接在 Github 存储库中创建问题，对吗？首先，我们必须登录，然后搜索 repo，然后我们才能创建问题。当然，上面的场景是可以允许的，但是用户的代码会被大量样板代码污染：RtRepo 可能*必须*通过其构造函数获取某种授权对象，授权客户端并获得正确的 repo ETC。

接口还提供了易于扩展性和向后兼容性。一方面，我们作为开发人员必须尊重已经发布的合约，另一方面，用户可以扩展我们提供的接口——他可以装饰它们或编写替代实现。

也就是说，尽可能地抽象和封装。通过使用接口，我们可以以优雅且不受限制的方式做到这一点——我们执行架构规则，同时让程序员自由地增强或更改我们公开的行为。

要结束本节，请记住：我们的图书馆，我们的规则。我们应该确切地知道客户的代码将是什么样子以及他将如何对其进行单元测试。如果我们不知道这一点，那么没有人会知道，我们的图书馆只会为创建难以理解和维护的代码做出贡献。

## 4. 第三方

请记住，一个好的库是一个轻量级的库。您的代码可能会解决问题并发挥作用，但如果 jar 将 10 MB 添加到我的构建中，那么很明显您很久以前就丢失了项目的蓝图。如果您需要很多依赖项，您可能试图涵盖太多功能，应该将项目分解为多个较小的项目。

尽可能透明，尽可能不要绑定到实际实现。想到的最好的例子是：使用 SLF4J，它只是一个用于日志记录的 API——不要直接使用 log4j，也许用户想使用其他记录器。

通过您的项目传递的文档库，并确保您不包含危险的依赖项，例如*xalan*或*xml-apis*（为什么它们是危险的，本文不做详细说明）。

这里的底线是：保持你的构建轻盈、透明，并且始终知道你在使用什么。它可以为您的用户节省比您想象的更多的麻烦。

## 5.结论

本文概述了一些简单的想法，可以帮助项目在可用性方面保持稳定。库作为一个组件，应该在更大的上下文中找到自己的位置，应该功能强大，同时提供流畅且精心设计的界面。

这是一个简单的越界步骤，并使设计变得一团糟。贡献者总是知道如何使用它，但第一个看到它的新手可能不知道。生产力是最重要的，遵循这一原则，用户应该能够在几分钟内开始使用图书馆。