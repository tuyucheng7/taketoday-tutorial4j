---
layout: post
title:  使用Selenium处理浏览器选项卡
category: java
copyright: java
excerpt: Java
---

## 1.概述

在本文中，我们将了解什么是内在函数以及它们在Java和其他基于JVM的语言中的工作方式。

## 2.什么是内在函数？

内部[函数](https://en.wikipedia.org/wiki/Intrinsic_function)是编译器或解释器对我们的编程语言进行特殊处理的函数。更具体地说，这是一种特殊情况，编译器或解释器可以出于各种原因用替代实现替换函数。

编程语言通常通过理解特定的方法调用是特殊的来处理这个问题，并且每当我们调用这个方法时，结果行为都是不同的。这使我们的代码看起来与正常代码没有什么不同，但编程语言的实现可以在特殊情况下进行干预以提供额外的好处。

它的确切工作方式因编程语言以及操作系统和硬件而异。但是，因为这些都是为我们处理的，所以我们通常不需要知道这些细节中的任何一个。

内在物质可以带来各种好处。用本机代码替换特定算法可以使它们执行得更好，甚至可以利用操作系统的特定功能或底层硬件。

## 3.JVM上的内在函数

JVM通过用替代版本替换对确切类的确切方法调用来实现内部函数。JVM自己处理这个，所以它只适用于核心类和特定架构。它还允许只换出某些方法，而不是整个类。

JVM之间的确切工作方式会有所不同。这不仅包括不同版本的JVM——例如Java 8与Java 11。这还包括不同的JVM目标——例如Linux与Windows——尤其是JVM供应商——Oracle与IBM。在某些情况下，传递给JVM的某些命令行标志会影响它们。

这种多样性意味着无法仅根据应用程序来确定哪些方法将被内部替换，哪些不会。根据运行应用程序的JVM，它会有所不同。但这在某些情况下可能会导致令人惊讶的结果——包括仅通过更改所使用的JVM就可以获得显着的性能优势。

## 4.性能优势

内部函数通常用于实现相同代码的更高效版本，例如，通过利用正在运行的操作系统或CPU的实现细节。有时这是因为它可以使用更高效的实现，而其他时候它甚至可以使用特定于硬件的功能。

例如，HotSpotJDK对java.lang.Math中的许多方法都有一个内部实现。根据确切的JVM，这些可能会使用CPU指令来执行所需的精确计算。

一个简单的测试将证明这一点。例如，以java.lang.Math.sqrt()为例。我们可以写一个测试：

```java
for (int a = 0; a < 100000; ++a) {
    double result = Math.sqrt(a);
}

```

该测试执行100,000次平方根运算，耗时约123毫秒。但是，如果我们将此代码替换为Math.sqrt()实现的副本：

```java
double result = StrictMath.sqrt(a);
```

此代码执行相同的操作，但执行时间为166毫秒。通过复制实现而不是允许JVM将其替换为内部版本，增加了35%。

## 5.不可能的实现

在其他情况下，内在函数用于无法在Java中实现代码的情况。这些通常保留用于非常低级别的情况。

例如，让我们看一下java.lang.Thread类中的onSpinWait()方法。此方法指示此线程当前未执行任何工作，可以将CPU时间分配给另一个线程。要实现这一点，它需要在尽可能低的级别上工作。

用于x86架构的HotSpotJDK使用PAUSE操作码直接在CPU上实现这一点。实现此目的的唯一其他方法是使用对本机代码的[JNI](https://www.baeldung.com/jni)调用，而这样做所涉及的开销首先会抵消调用的好处。

## 6.识别Java中的内在函数

不幸的是，没有保证的方法来识别可能被内部版本替换的方法。这是因为不同的JVM甚至不同平台上的同一个JVM会针对不同的方法执行此操作。

但是，从Java 9开始使用HotspotJVM时，@HotSpotIntrinsicCandidate注释用于所有可能被替换的方法。添加此注释不会自动导致方法被替换。实际上，这发生在底层JVM中。相反，JVM开发人员知道这些方法很特殊并且要小心使用它们。

其他JVM可能会以不同方式处理此问题，如果它们被识别的话。这包括Java 8或更早版本中的HotspotJVM。

## 七、总结

我们不能编写我们的程序来依赖内部函数的存在，因为没有办法知道它们在运行时JVM上是否可用。但是，它们是JVM可以用来改进程序工作方式的一种引人注目的方法。

这些内在函数可以——而且经常——被添加到JVM的新版本中。然后，这允许通过升级我们正在运行的JVM来改进我们已经运行的代码，因此这是确保我们与依赖项和运行时保持同步的另一个原因。
