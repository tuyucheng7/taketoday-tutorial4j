## 一、简介

当我们用 Java 编程时，我们经常使用硬引用，通常甚至都没有考虑过——这是有充分理由的，因为它们是大多数情况下的最佳选择。然而，有时我们需要更多地控制对象可用于垃圾收集器清除的时间。

在本文中，我们将探讨硬引用类型和各种非硬引用类型之间的区别以及何时可以使用它们。

## 2.硬参考

硬（或强）引用是默认的引用类型，大多数时候，我们甚至可能没有想过引用的对象何时以及如何被垃圾回收。**如果可以通过任何强引用访问该对象，则该对象不能被垃圾回收。**假设我们创建了一个*ArrayList*对象并将其分配给*列表*变量：

```java
List<String> list = new ArrayList<>;复制
```

垃圾收集器无法收集这个列表，因为我们在*列表*变量中持有对它的强引用。但是如果我们然后使变量无效：

```java
list = null;复制
```

现在，也只是现在，可以收集*ArrayList对象，因为没有任何对象持有对它的引用。*

## 3. 超越硬引用

硬引用是默认值是有充分理由的。它们让垃圾收集器按预期工作，因此我们不必担心管理内存分配。尽管如此，在某些情况下，即使我们仍然持有对这些对象的引用，我们仍希望收集对象并释放内存。

## 4. 软引用

软[引用](https://www.baeldung.com/java-soft-references)告诉垃圾收集器可以根据收集器的判断收集引用的对象。对象可以在内存中保留一段时间，直到收集器决定他需要收集它。这种情况会发生，尤其是当 JVM 面临内存不足的风险时。**在抛出*****OutOfMemoryError\*****异常之前，应清除所有对只能通过软引用访问的对象的软引用。**

我们可以通过将它包装在我们的对象周围来轻松地使用软引用：

```java
SoftReference<List<String>> listReference = new SoftReference<List<String>>(new ArrayList<String>());复制
```

如果我们想要检索引用对象，我们可以使用*get* 方法。因为该对象可能已经被清除，所以我们需要检查它：

```java
List<String> list = listReference.get();
if (list == null) {
    // object was already cleared
}复制
```

### 4.1. 用例

软引用可用于**使我们的代码对与内存不足相关的错误更有弹性**。例如，我们可以创建一个内存敏感的缓存，当内存不足时自动清除对象。我们不需要手动管理内存，因为垃圾收集器会为我们做这件事。

## 5.弱引用

**不会阻止收集仅由[弱引用](https://www.baeldung.com/java-weak-reference)引用的对象。**从垃圾回收的角度来看，它们根本不可能存在。如果一个弱引用的对象应该被保护不被清除，它也应该被一些硬引用引用。

### 5.1. 用例

弱引用最常用于**创建规范化映射**。这些是仅映射可以到达的对象的映射。一个很好的例子是*WeakHashMap ，它像普通的**HashMap*一样工作，但它的键是弱引用的，当引用被清除时它们会自动删除。

使用*WeakHashMap*，我们可以创建一个短期缓存，用于清除代码其他部分不再使用的对象。如果我们使用普通的*HashMap，那么*仅仅存在映射中的键就会阻止它被垃圾收集器清除。

## 6.幻影参考

与弱引用类似，[幻象引用](https://www.baeldung.com/java-phantom-reference)不会禁止垃圾收集器将对象排入队列以进行清除。不同之处在于**幻象引用必须在最终确定之前从引用队列中手动轮询**。这意味着我们可以在它们被清除之前决定我们想做什么。

### 6.1. 用例

**如果我们需要实现一些终结逻辑**，幻影引用就非常有用，而且它们比[*终结*](https://www.baeldung.com/java-finalize)方法更可靠、更灵活。让我们编写一个简单的方法，它将遍历引用队列并对所有引用执行清理：

```java
private static void clearReferences(ReferenceQueue queue) {
    while (true) {
        Reference reference = queue.poll();
        if (reference == null) {
            break; // no references to clear
        }
        cleanup(reference);
    }
}复制
```

幻引用不允许我们使用*get*方法检索它们的引用对象。因此，通常的做法是使用我们自己的类来扩展*PhantomReference类，其中包含对清理逻辑很重要的信息。*

幻象引用的其他重要用例是**调试和内存泄漏检测**。即使我们不需要执行任何终结操作，我们也可以使用幻像引用来观察哪些对象正在被释放以及何时被释放。

## 七、结论

在本文中，我们探讨了硬引用和不同类型的非硬引用及其用例。我们了解到，软引用可用于内存保护，弱引用可用于规范化映射，幻象引用可用于细粒度终结。