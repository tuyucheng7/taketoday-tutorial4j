## 一、简介

如今，应用程序同时为数千甚至数百万用户提供服务的情况并不少见。此类应用程序需要大量内存。但是，管理所有这些内存可能很容易影响应用程序性能。

为了解决这个问题，Java 11 引入了[Z 垃圾收集器](https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html)(ZGC) 作为实验性垃圾收集器 (GC) 实现。

在本教程中，我们将了解**ZGC 如何设法在数 TB 的堆上保持低暂停时间**。

## 二、主要概念

[要了解 ZGC 的工作原理，我们需要了解内存管理](https://www.baeldung.com/java-memory-management-interview-questions)和[垃圾收集器](https://www.baeldung.com/jvm-garbage-collectors)背后的基本概念和术语。

### 2.1. 内存管理

物理内存是我们的硬件提供的 RAM。

操作系统（OS）为每个应用程序分配[虚拟内存](https://www.baeldung.com/cs/virtual-memory)空间。

当然，**我们将虚拟内存存放在物理内存中，OS负责维护两者之间的映射关系。**这种映射通常涉及硬件加速。

### 2.2. 多重映射

多映射是指虚拟内存中有特定的地址，指向物理内存中的同一个地址。由于应用程序通过虚拟内存访问数据，因此它们对这种机制一无所知（而且它们也不需要）。

**实际上，我们将虚拟内存的多个范围映射到物理内存中的相同范围：**

[![zgc 多映射](https://www.baeldung.com/wp-content/uploads/2019/02/zgc-multimapping.png)](https://www.baeldung.com/wp-content/uploads/2019/02/zgc-multimapping.png)

乍一看，它的用例并不明显，但稍后我们会看到，ZGC 需要它来发挥其魔力。此外，它还提供了一些安全性，因为它分隔了应用程序的内存空间。

### 2.3. 搬迁

由于我们使用动态内存分配，因此随着时间的推移，普通应用程序的内存会变得碎片化。这是因为当我们释放内存中间的一个对象时，那里还留有一块空闲空间。随着时间的推移，这些间隙不断累积，我们的记忆看起来就像一个棋盘，由空闲空间和已用空间的交替区域组成。

当然，我们可以尝试用新对象来填补这些空白。为此，我们应该扫描内存以寻找足够大的可用空间来容纳我们的对象。这样做是一项昂贵的操作，尤其是当我们每次要分配内存时都必须这样做。此外，内存仍将是碎片化的，因为我们可能无法找到具有所需大小的可用空间。因此，对象之间会存在间隙。当然，这些差距较小。此外，我们可以尝试最小化这些差距，但它会使用更多的处理能力。

另一种策略是以**更紧凑的格式频繁地将对象从碎片内存区域重新定位到空闲区域**。为了更有效，我们将内存空间分成块。我们重新定位块中的所有对象或不重新定位它们。这样，内存分配会更快，因为我们知道内存中有整个空块。

### 2.4. 垃圾收集

当我们创建一个 Java 应用程序时，我们不必释放我们分配的内存，因为垃圾收集器为我们做了这件事。总之，**GC 通过引用链监视我们可以从应用程序中访问哪些对象，并释放我们无法访问的对象**。

GC 需要跟踪堆空间中对象的状态才能完成其工作。例如，一个可能的状态是可达的。这意味着应用程序持有对该对象的引用。此引用可能是可传递的。唯一重要的是应用程序可以通过引用访问这些对象。另一个例子是可终结的：我们无法访问的对象。这些是我们认为垃圾的对象。

[![zgc打标](https://www.baeldung.com/wp-content/uploads/2019/02/zgc-marking.png)](https://www.baeldung.com/wp-content/uploads/2019/02/zgc-marking.png)

为了实现它，垃圾收集器有多个阶段。

### 2.5. GC 相性质

GC 阶段可以具有不同的属性：

-   并行阶段可以在多个**GC**线程上运行
-   **串行**阶段在单个线程上运行
-   停止**世界**阶段不能与应用程序代码同时运行
-   并发阶段可以在后台运行，而我们的应用程序会执行它的**工作**
-   **增量**阶段可以在完成所有工作之前终止并在以后继续

请注意，上述所有技术都有其优点和缺点。例如，假设我们有一个可以与我们的应用程序同时运行的阶段。此阶段的串行实现需要 1% 的整体 CPU 性能并运行 1000 毫秒。相比之下，并行实现使用 30% 的 CPU 并在 50 毫秒内完成其工作。

在这个例子中，**并行解决方案总体上使用了更多的 CPU，因为它可能更复杂并且必须同步线程**。对于 CPU 繁重的应用程序（例如，批处理作业），这是一个问题，因为我们没有足够的计算能力来完成有用的工作。

当然，这个例子有虚构的数字。但是，很明显，所有应用程序都有其特点，因此它们对 GC 的要求也不同。

有关更详细的说明，请访问[我们关于 Java 内存管理的文章](https://www.baeldung.com/java-memory-management-interview-questions)。

## 3. 中关村理念

ZGC 打算提供尽可能短的 stop-the-world 阶段。它以这样一种方式实现它，即这些暂停时间的持续时间不会随着堆大小的增加而增加。**这些特性使 ZGC 非常适合服务器应用程序，其中大堆很常见，并且需要快速的应用程序响应时间。**

在久经考验的 GC 技术之上，ZGC 引入了新概念，我们将在以下部分中介绍这些概念。

但现在，让我们看一下 ZGC 工作原理的整体情况。

### 3.1. 大图

ZGC 有一个称为标记的阶段，我们在其中找到可达对象。GC 可以通过多种方式存储对象状态信息。例如，我们可以创建一个*Map，*其中键是内存地址，值是该地址处对象的状态。它很简单，但需要额外的内存来存储这些信息。此外，维护这样的地图可能具有挑战性。

**ZGC 使用不同的方法：它将引用状态存储为引用的位。**这称为参考着色。但是这样我们就有了新的挑战。设置引用的位来存储对象的元数据意味着多个引用可以指向同一个对象，因为状态位不包含有关对象位置的任何信息。多重映射来拯救！

我们还想减少内存碎片。ZGC 使用重定位来实现这一点。但是对于大堆，重定位是一个缓慢的过程。**由于 ZGC 不希望有较长的暂停时间，因此它会与应用程序并行执行大部分重定位。**但这引入了一个新问题。

假设我们有一个对象的引用。ZGC 重新定位它，并发生上下文切换，应用程序线程运行并尝试通过其旧地址访问该对象。ZGC 使用负载屏障来解决这个问题。**加载屏障是当线程从堆中加载引用时运行的一段代码**——例如，当我们访问对象的非原始字段时。

在 ZGC 中，负载屏障检查引用的元数据位。根据这些位，**ZGC 可能会在我们获取引用之前对其执行一些处理。**因此，它可能会产生完全不同的参考。我们称之为重新映射。

### 3.2. 打标

ZGC 将标记分为三个阶段。

第一阶段是停止世界阶段。在这个阶段，我们寻找根引用并标记它们。**根引用是到达堆中对象的起点**，例如局部变量或静态字段。由于根引用的数量通常很少，所以这个阶段很短。

下一阶段是并发的。在此阶段，**我们遍历对象图，从根引用开始。我们标记我们到达的每个对象。**此外，当负载屏障检测到未标记的引用时，它也会对其进行标记。

最后一个阶段也是一个 stop-the-world 阶段，用于处理一些边缘情况，比如弱引用。

在这一点上，我们知道我们可以到达哪些对象。

ZGC 使用*marked0*和*marked1 元*数据位进行标记。

### 3.3. 参考着色

引用代表一个字节在虚拟内存中的位置。然而，我们不必使用引用的所有位来做到这一点——**一些位可以表示引用的属性**。这就是我们所说的参考着色。

使用 32 位，我们可以寻址 4 GB。由于现在计算机普遍拥有比这更多的内存，我们显然不能使用这 32 位中的任何一个来着色。因此，ZGC 使用 64 位引用。这意味着**ZGC 仅适用于 64 位平台：**

[![zgc指针](https://www.baeldung.com/wp-content/uploads/2019/02/zgc-pointer.png)](https://www.baeldung.com/wp-content/uploads/2019/02/zgc-pointer.png)

ZGC 引用使用 42 位来表示地址本身。因此，ZGC 引用可以寻址 4 TB 的内存空间。

最重要的是，我们有 4 位来存储参考状态：

-   ***可终结\***位——对象只能通过终结器访问
-   ***重映射\***位——引用是最新的并指向对象的当前位置（参见重定位）
-   ***marked0\***和***marked1\***位——这些用于标记可到达的对象

我们也称这些位为元数据位。在 ZGC 中，这些元数据位中恰好有一个是 1。

### 3.4. 搬迁

在 ZGC 中，搬迁包括以下几个阶段：

1.  并发阶段，寻找块，我们要重定位并将它们放入重定位集中。
2.  stop-the-world 阶段重新定位重定位集中的所有根引用并更新它们的引用。
3.  并发阶段重新定位重定位集中所有剩余的对象，并将旧地址和新地址之间的映射存储在转发表中。
4.  剩余引用的重写发生在下一个标记阶段。这样，我们就不必遍历对象树两次。或者，负载屏障也可以做到这一点。

### 3.5. 重新映射和负载屏障

请注意，在重定位阶段，我们没有重写对重定位地址的大部分引用。因此，使用这些引用，我们不会访问我们想要访问的对象。更糟糕的是，我们可以访问垃圾。

ZGC 使用负载屏障来解决这个问题。**负载屏障使用称为重新映射的技术修复指向重定位对象的引用。**

当应用程序加载引用时，它会触发加载屏障，然后按照以下步骤返回正确的引用：

1.  *检查重映射*位是否设置为 1。如果是，则表示引用是最新的，因此我们可以安全地返回它。
2.  然后我们检查引用的对象是否在重定位集中。如果不是，那就意味着我们不想重新安置它。为避免下次加载此引用时进行此检查，我们将 *重映射*位设置为 1 并返回更新后的引用。
3.  现在我们知道我们要访问的对象是重定位的目标。唯一的问题是搬迁是否发生？如果对象已被重新定位，我们将跳到下一步。否则，我们现在重新定位它并在转发表中创建一个条目，该条目存储每个重新定位的对象的新地址。在此之后，我们继续下一步。
4.  现在我们知道该对象已重新定位。通过 ZGC，我们在上一步中，或在此对象的早期命中期间的负载屏障。我们将此引用更新为对象的新位置（使用上一步的地址或通过在转发表中查找），设置重映射位，然后*返回*引用。

就是这样，通过上述步骤，我们确保每次尝试访问一个对象时，我们都能获得对它的最新引用。因为每次我们加载一个引用，它都会触发加载屏障。因此它会降低应用程序性能。特别是我们第一次访问重定位的对象时。但如果我们想要短暂停时间，这是我们必须付出的代价。由于这些步骤相对较快，因此不会显着影响应用程序性能。

## 4.如何启用ZGC？

在运行我们的应用程序时，我们可以使用以下命令行选项启用 ZGC：

```bash
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC复制
```

请注意，由于 ZGC 是实验性 GC，因此需要一些时间才能获得正式支持。

## 5.结论

在这篇文章中，我们看到 ZGC 打算支持大堆大小和低应用程序暂停时间。

为实现这一目标，它使用了多种技术，包括彩色 64 位引用、负载屏障、重定位和重新映射。