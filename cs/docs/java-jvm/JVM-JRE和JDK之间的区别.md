## 1. 概述

在本文中，我们将通过考虑它们的组件和用途来讨论 JVM、JRE 和 JDK 之间的差异。

## 2.虚拟机

Java虚拟机(JVM)是执行Java程序的虚拟机的实现。

JVM 首先解释字节码。然后它将类信息存储在内存区域中。最后，它执行java编译器生成的字节码。

它是一个抽象的计算机器，有自己的指令集，并在运行时操作各种内存区域。

JVM 的组件是：

-   类加载器
-   运行时数据区
-   执行引擎

### 2.1. 类加载器

JVM 的初始任务包括加载、验证和链接字节码。类加载器处理这些任务。

我们有一篇专门针对[类加载器](https://www.baeldung.com/java-classloaders)的详细文章。

### 2.2. 运行时数据区

JVM 定义了各种内存区域来执行 Java 程序。这些在运行时使用，称为运行时数据区。其中一些区域在 JVM 启动时创建并在 JVM 退出时销毁，而另一些区域在创建线程时创建并在线程退出时销毁。

让我们一一考虑这些领域：

方法区

基本上，方法区类似于编译代码的存储区。它存储诸如运行时常量池、字段和方法数据、方法和构造函数代码以及完全限定的类名等结构。JVM 为每个类存储这些结构。

方法区，也称为永久代空间(PermGen)，是在JVM启动时创建的。这个区域的内存不需要是连续的。所有的 JVM 线程共享这个内存区域。

堆区

JVM 从该区域为所有类实例和数组分配内存。

垃圾收集器 (GC) 回收对象的堆内存。基本上，GC 有三个阶段来从对象中回收内存，即。两次次要 GC 和一次主要 GC。

堆内存分为三部分：

-   Eden Space——它是年轻一代空间的一部分。当我们创建一个对象时，JVM从这个空间分配内存
-   幸存者空间——它也是年轻一代空间的一部分。幸存者空间包含在 GC 的次要 GC 阶段中幸存下来的现有对象
-   Tenured Space——这也被称为 Old Generation 空间。它持有长期存在的对象。基本上，为年轻一代对象设置了一个阈值，当满足该阈值时，这些对象将被移动到永久空间。

JVM一启动就创建堆区。JVM 的所有线程共享这个区域。堆区的内存不需要是连续的。

堆叠区

将数据存储为帧，每个帧存储局部变量、部分结果和嵌套方法调用。JVM 在创建新线程时创建堆栈区域。该区域对于每个线程都是私有的。

堆栈中的每个条目称为堆栈帧或激活记录。每个框架包含三个部分：

-   局部变量数组——包含方法的所有局部变量和参数
-   操作数栈——用作存储中间计算结果的工作空间
-   帧数据——用于存储部分结果、方法的返回值，以及对异常表的引用，该表在发生异常时提供相应的捕获块信息

JVM 堆栈的内存不需要是连续的。

PC寄存器

每个 JVM 线程都有一个单独的 PC 寄存器，用于存储当前正在执行的指令的地址。如果当前执行的指令是本地方法的一部分，那么这个值是未定义的。

本机方法堆栈

本机方法是那些用 Java 以外的语言编写的方法。

JVM 提供了调用这些本地方法的能力。本机方法堆栈也称为“C 堆栈”。它们存储本机方法信息。每当本地方法被编译成机器代码时，它们通常使用本地方法堆栈来跟踪它们的状态。

JVM 在创建新线程时创建这些堆栈。因此 JVM 线程不共享这个区域。

### 2.3. 执行引擎

执行引擎使用内存区域中的信息执行指令。它分为三个部分：

口译员

一旦类加载器加载并验证了字节码，解释器就会逐行执行字节码。这个执行很慢。解释器的缺点是当多次调用一个方法时，每次都需要重新解释。

然而，JVM 使用 JIT 编译器来减轻这个缺点。

即时 (JIT) 编译器

JIT 编译器在运行时将经常调用的方法的字节码编译成本地代码。因此，它负责 Java 程序的优化。

JVM 自动监视哪些方法正在执行。一旦一个方法符合 JIT 编译的条件，它就会被安排编译成机器代码。这种方法被称为热方法。这种对机器代码的编译发生在一个单独的 JVM 线程上。

因此，它不会中断当前程序的执行。编译成机器码后，运行速度更快。

垃圾收集器

Java 使用垃圾收集来管理内存。这是一个查看堆内存，识别哪些对象在使用中，哪些没有使用，最后删除未使用的对象的过程。

GC是一个守护线程。可以使用System. gc ()方法，但是它不会立即执行，JVM 决定何时调用 GC。

### 2.4. Java 本机接口

它充当 Java 代码和本机 (C/C++) 库之间的接口。

在某些情况下，仅靠 Java 无法满足应用程序的需求，例如，实现依赖于平台的功能。

在那些情况下，我们可以使用 JNI 来使运行在 JVM 中的代码能够调用。相反，它使本地方法能够调用在 JVM 中运行的代码。

### 2.5. 本机库

这些是特定于平台的库，包含本地方法的实现。

## 3.JRE

Java 运行时环境 (JRE) 是一组用于运行 Java 应用程序的软件组件。

JRE 的核心组件包括：

-   Java 虚拟机 (JVM) 的实现
-   运行 Java 程序所需的类
-   属性文件

我们在上一节中讨论了 JVM。这里我们将重点关注核心类和支持文件。

### 3.1. 引导类

我们将在 jre/lib/下找到引导程序类。此路径也称为引导程序类路径。 这包括：

-   rt.jar中的运行时类
-   i18n.jar中的国际化类
-   charsets.jar中的字符转换类
-   其他

Bootstrap ClassLoader 在 JVM 启动时加载这些类。

### 3.2. 扩展班

我们可以在jre/lib/extn/中找到扩展类，它充当 Java 平台扩展的目录。此路径也称为扩展类路径。

它在jfxrt.jar中包含 JavaFX 运行时库，在localedata.jar中包含java.text和java.util包的语言环境数据。用户还可以将自定义 jar 添加到此目录中。

### 3.3. 属性设置

Java 平台使用这些属性设置来维护其配置。根据它们的用途，它们位于 /jre/lib/内的不同文件夹中。这些包括：

-   calendar.properties 中的日历配置
-   logging.properties中的日志记录配置
-   net.properties中的网络配置
-   /jre/lib/deploy/中的部署属性 
-   /jre/lib/management/中的管理属性

### 3.4. 其他文件

除了上述文件和类之外，JRE 还包含其他事项的文件：

-   jre/lib/security的安全管理
-   放置小程序支持类的目录在jre/lib/applet
-   jre/lib/fonts等中的字体相关文件

## 4.JDK

Java Development Kit (JDK) 提供了开发、编译、调试和执行 Java 程序的环境和工具。

JDK的核心组件包括：

-   JRE
-   开发工具

我们在上一节中讨论了 JRE。

现在，我们将专注于各种开发工具。让我们根据用途对这些工具进行分类：

### 4.1. 基本工具

这些工具奠定了 JDK 的基础，用于创建和构建 Java 应用程序。在这些工具中，我们可以找到用于编译、调试、归档、生成 Javadoc 等的实用程序。

他们包括：

-   javac——读取类和接口定义并将它们编译成类文件
-   java – 启动 Java 应用程序
-   javadoc – 从 Java 源文件生成 API 文档的 HTML 页面
-   apt – 根据指定源文件集中存在的注释查找并执行注释处理器
-   appletviewer – 使我们能够在没有网络浏览器的情况下运行 Java 小程序
-   jar – 将 Java 小程序或应用程序打包到一个存档中
-   jdb – 一种命令行调试工具，用于查找和修复 Java 应用程序中的错误
-   javah—— 从 Java 类生成 C 头文件和源文件
-   javap – 反汇编类文件并显示有关类文件中存在的字段、构造函数和方法的信息
-   extcheck – 检测目标 Java 存档 (JAR) 文件和当前安装的扩展 JAR 文件之间的版本冲突

### 4.2. 安全工具

其中包括用于操作 Java 密钥库的密钥和证书管理工具。

Java Keystore 是授权证书或公钥证书的容器。因此，它经常被基于 Java 的应用程序用于加密、身份验证和通过 HTTPS 提供服务。

此外，它们还有助于在我们的系统上设置安全策略，并创建可以在生产环境中在这些策略范围内工作的应用程序。这些包括：

-   keytool – 帮助管理密钥库条目，即加密密钥和证书
-   jarsigner – 使用密钥库信息生成数字签名的 JAR 文件
-   policytool – 使我们能够管理定义安装安全策略的外部策略配置文件

一些安全工具还有助于管理 Kerberos 票证。

Kerberos 是一种网络身份验证协议。

它基于票证工作，允许节点通过非安全网络进行通信，以安全的方式相互证明自己的身份：

-   kinit – 用于获取和缓存 Kerberos 票证授予票证
-   ktab—— 管理密钥表中的主体名称和密钥对
-   klist – 显示本地凭证缓存和密钥表中的条目

### 4.3. 国际化工具

国际化是设计应用程序的过程，以便它可以适应各种语言和地区而无需进行工程更改。

为此，JDK 带来了 native2ascii。 此工具将具有 JRE 支持的字符的文件转换为以 ASCII 或 Unicode 转义编码的文件。

### 4.4. 远程方法调用 (RMI) 工具

RMI 工具支持 Java 应用程序之间的远程通信，从而为分布式应用程序的开发提供了空间。

RMI 使在一个 JVM 中运行的对象能够调用在另一个 JVM 中运行的对象的方法。这些工具包括：

-   rmic – 使用 Java 远程方法协议 (JRMP) 或 Internet Inter-Orb 协议 (IIOP) 为远程对象生成存根、骨架和连接类
-   rmiregistry – 创建并启动远程对象注册表
-   rmid –s启动激活系统守护进程。这允许在 Java 虚拟机中注册和激活对象
-   serialver – 返回指定类的串行版本 UID

### 4.5. Java IDL 和 RMI-IIOP 工具

Java 接口定义语言 (IDL) 将通用的基于对象的请求代理体系结构 (CORBA) 功能添加到 Java 平台。

这些工具使分布式 Java Web 应用程序能够使用行业标准对象管理组 (OMG) – IDL 调用远程网络服务上的操作。

同样，我们可以使用 Internet InterORB 协议 (IIOP)。

RMI-IIOP，即 RMI over IIOP 支持通过 RMI API 对 CORBA 服务器和应用程序进行编程。因此，可以通过 Internet InterORB 协议 (IIOP) 在以任何 CORBA 兼容语言编写的两个应用程序之间建立连接。

这些工具包括：

-   tnameserv – 临时命名服务，为对象引用提供树结构目录
-   idlj—— IDL-to-Java 编译器，用于为指定的 IDL 文件生成 Java 绑定
-   orbd – 使客户端能够在 CORBA 环境中透明地定位和调用服务器上的持久对象
-   servertool – 提供命令行界面以向 ORB 守护进程 ( orbd ) 注册或注销持久服务器，启动和关闭向 ORB 守护进程注册的持久服务器等

### 4.6. Java 部署工具

这些工具有助于在 Web 上部署 Java 应用程序和小程序。他们包括：

-   pack200 – 使用 Java gzip压缩器将 JAR 文件转换为 pack200文件
-   unpack200 –将 pack200文件转换为 JAR 文件

### 4.7. Java插件工具

JDK为我们提供了 htmlconverter。此外，它还与 Java 插件一起使用。

一方面，Java Plug-in 在流行的浏览器和Java 平台之间建立了连接。由于这种连接，网站上的小程序可以在浏览器中运行。

另一方面，htmlconverter是一个实用程序，用于将包含小程序的 HTML 页面转换为 Java 插件格式。

### 4.8. Java Web 启动工具

JDK自带 javaws。 我们可以将它与 Java Web Start 结合使用。

该工具允许我们通过单击浏览器来下载和启动 Java 应用程序。 因此，无需运行任何安装过程。

### 4.9. 监控和管理工具

这些是我们可以用来监控 JVM 性能和资源消耗的好工具。以下是其中的一些：

-   jconsole –提供一个图形控制台，让你监控和管理 Java 应用程序
-   jps –列出目标系统上已检测的 JVM
-   jstat –监控 JVM 统计信息
-   jstatd –监控已检测 JVM 的创建和终止

### 4.10. 故障排除工具

这些是我们可以用于故障排除任务的实验工具：

-   info—— 生成指定Java进程的配置信息
-   jmap –打印指定进程的共享对象内存映射或堆内存详细信息
-   jsadebugd –附加到 Java 进程并充当调试服务器
-   jstack –打印给定 Java 进程的 Java 线程的 Java 堆栈跟踪

## 5.总结

在本文中，我们发现 JVM、JRE 和 JDK 之间的基本区别在于它们的用法。

首先，我们描述了 JVM 如何成为一个实际执行 Java 字节码的抽象计算机器。

然后，我们解释了如何只运行 Java 应用程序，我们使用 JRE。

最后，我们了解了如何开发 Java 应用程序，我们使用 JDK。

我们还花了一些时间来深入研究这些组件的工具和基本概念。