## **一、简介**

为了以最佳方式运行应用程序，JVM 将内存分为堆栈内存和堆内存。**每当我们声明新变量和对象、调用新方法、声明\*String\*或执行类似操作时，JVM 都会从 Stack Memory 或 Heap Space 中为这些操作指定内存。**

在本教程中，我们将研究这些内存模型。首先，我们将探索它们的主要功能。然后我们将了解它们如何存储在 RAM 中，以及在哪里使用它们。最后，我们将讨论它们之间的主要区别。

## **2. Java中的栈内存**

**Java 中的堆栈内存用于静态内存分配和线程的执行。**它包含特定于方法的原始值和对从堆中的方法引用的对象的引用。

对该内存的访问是按后进先出 (LIFO) 顺序进行的。每当我们调用一个新方法时，都会在堆栈顶部创建一个新块，其中包含特定于该方法的值，例如原始变量和对对象的引用。

当方法完成执行时，其对应的堆栈帧被刷新，流程返回到调用方法，并且有空间可供下一个方法使用。

### **2.1. 堆栈存储器的主要特性**

堆栈存储器的一些其他特性包括：

-   它会随着新方法的调用和返回分别增长和缩小。
-   只要创建它们的方法正在运行，堆栈中的变量就会存在。
-   当方法完成执行时，它会自动分配和释放。
-   如果此内存已满，Java 将抛出*java.lang.StackOverFlowError。*
-   与堆内存相比，访问此内存的速度很快。
-   该内存是线程安全的，因为每个线程都在自己的堆栈中运行。

## **3. Java 中的堆空间**

**堆空间用于 Java 对象和 JRE 类在运行时的动态内存分配**。新对象总是在堆空间中创建，对这些对象的引用存储在堆栈内存中。

这些对象具有全局访问权限，我们可以从应用程序的任何位置访问它们。

我们可以将这个内存模型分解成更小的部分，称为世代，它们是：

1.  **新生代——**这是分配和老化所有新对象的地方。当它填满时，会发生一次次要的垃圾收集。
2.  **Old or Tenured Generation——**这是存储长期存活对象的地方。当对象存储在新生代时，会设置一个对象的年龄阈值，当达到该阈值时，将对象移至老年代。
3.  **永久代——**这包括运行时类和应用程序方法的 JVM 元数据。

[这些不同的部分也在JVM、JRE 和 JDK 之间的差异](https://www.baeldung.com/jvm-vs-jre-vs-jdk)一文中进行了讨论。

我们总是可以根据需要操纵堆内存的大小。有关更多信息，请访问这篇[链接的 Baeldung 文章](https://www.baeldung.com/jvm-parameters)。

### **3.1. Java 堆内存的主要特性**

堆空间的其他一些特性包括：

-   它通过复杂的内存管理技术访问，包括新生代、老年代或永久代以及永久代。
-   如果堆空间已满，Java 将抛出 *java.lang.OutOfMemoryError。*
-   访问此内存比堆栈内存慢
-   与堆栈不同，此内存不会自动释放。它需要垃圾收集器来释放未使用的对象，以保持内存使用的效率。
-   与堆栈不同，堆不是线程安全的，需要通过正确同步代码来加以保护。

## **4.例子**

基于我们目前所学的知识，让我们分析一段简单的 Java 代码来评估如何在此处管理内存：

```java
class Person {
    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class PersonBuilder {
    private static Person buildPerson(int id, String name) {
        return new Person(id, name);
    }

    public static void main(String[] args) {
        int id = 23;
        String name = "John";
        Person person = null;
        person = buildPerson(id, name);
    }
}复制
```

让我们一步一步地分析这个：

1.  当我们进入

    main()

    方法时，会在堆栈内存中创建一个空间来存储该方法的原语和引用。

    -   栈内存直接存放整数id的原始值*。*
    -   *Person* 类型的引用变量*person* 也会在栈内存中创建，指向堆中的实际对象。

2.  从*main()*调用参数化构造函数 

    Person(int, String)

     将在先前堆栈的顶部分配更多内存。这将存储：

    

    

    -   栈内存中调用对象的*this*对象引用
    -   栈内存中的原始值 *id* 
    -   *String* argument *name*的引用变量，将指向堆内存中字符串池中的实际字符串

3.  主要方法是进一步调用*buildPerson()静态方法，进一步分配将在前一个之上的堆栈**内存*中进行。这将再次以上述方式存储变量。

4.  但是，堆内存将存储新创建的Person类型的 对象*person的所有实例变量**。*

让我们在下图中看一下这个分配：

![java堆堆栈图](https://www.baeldung.com/wp-content/uploads/2018/07/java-heap-stack-diagram.png)

## **5.总结**

在结束本文之前，让我们快速总结一下Stack Memory和Heap Space的区别：

| 范围          | 栈内存                                                 | 堆空间                                                       |
| ------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 应用          | 堆栈被分部分使用，在线程执行期间一次使用一个           | 整个应用程序在运行时使用堆空间                               |
| 尺寸          | Stack 有大小限制，具体取决于操作系统，通常小于 Heap    | 堆没有大小限制                                               |
| 贮存          | 仅存储原始变量和对在堆空间中创建的对象的引用           | 所有新创建的对象都存储在这里                                 |
| 命令          | 它使用后进先出 (LIFO) 内存分配系统进行访问             | 该内存通过复杂的内存管理技术访问，包括新生代、老年代或永久代以及永久代。 |
| 生活          | 堆栈内存仅在当前方法运行时存在                         | 只要应用程序运行，堆空间就存在                               |
| 效率          | 与堆相比，分配速度更快                                 | 与堆栈相比分配速度较慢                                       |
| 分配/解除分配 | 当一个方法被调用和返回时，这个内存分别被自动分配和释放 | 堆空间在创建新对象时分配，当不再被引用时由 Gargabe Collector 释放 |

## **六，结论**

栈和堆是Java分配内存的两种方式。在本文中，我们了解了它们的工作原理，以及何时使用它们来开发更好的 Java 程序。

要了解有关 Java 内存管理的更多信息，请在此处查看[这篇文章](https://www.baeldung.com/java-memory-management-interview-questions)。我们还谈到了 JVM 垃圾收集器，[本文对此](https://www.baeldung.com/jvm-garbage-collectors)进行了简要讨论。