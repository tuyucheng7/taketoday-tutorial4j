## 1. 概述

在这篇简短的文章中，我们将讨论Java泛型中一种称为类型擦除的重要机制的基础知识。

## 2. 什么是类型擦除？

**类型擦除可以解释为仅在[编译时](https://www.baeldung.com/cs/compile-load-execution-time)强制执行类型约束并在运行时丢弃元素类型信息的过程**。

例如：

```java
public static  <E> boolean containsElement(E [] elements, E element){
    for (E e : elements){
        if(e.equals(element)){
            return true;
        }
    }
    return false;
}
```

编译器将未绑定类型E替换为实际类型Object：

```java
public static  boolean containsElement(Object [] elements, Object element){
    for (Object e : elements){
        if(e.equals(element)){
            return true;
        }
    }
    return false;
}
```

因此，编译器确保我们代码的类型安全并防止运行时错误。

## 3. 类型擦除的类型

类型擦除可能发生在类(或变量)和方法级别。

### 3.1 类类型擦除

在类级别，编译器会丢弃类上的类型参数，并用它的第一个绑定替换它们，如果类型参数未绑定，则用Object替换它们。

让我们使用数组实现一个Stack：

```java
public class Stack<E> {
    private E[] stackContent;

    public Stack(int capacity) {
        this.stackContent = (E[]) new Object[capacity];
    }

    public void push(E data) {
        // ..
    }

    public E pop() {
        // ..
    }
}
```

编译后，编译器将未绑定类型参数E替换为Object：

```java
public class Stack {
    private Object[] stackContent;

    public Stack(int capacity) {
        this.stackContent = (Object[]) new Object[capacity];
    }

    public void push(Object data) {
        // ..
    }

    public Object pop() {
        // ..
    }
}
```

在绑定类型参数E的情况下：

```java
public class BoundStack<E extends Comparable<E>> {
    private E[] stackContent;

    public BoundStack(int capacity) {
        this.stackContent = (E[]) new Object[capacity];
    }

    public void push(E data) {
        // ..
    }

    public E pop() {
        // ..
    }
}
```

编译器会将绑定类型参数E替换为第一个绑定类，在本例中为Comparable：

```java
public class BoundStack {
    private Comparable[] stackContent;

    public BoundStack(int capacity) {
        this.stackContent = (Comparable[]) new Object[capacity];
    }

    public void push(Comparable data) {
        // ..
    }

    public Comparable pop() {
        // ..
    }
}
```

### 3.2 方法类型擦除

对于方法级类型擦除，方法的类型参数不会被存储，而是在未绑定时转换为其父类型Object或在绑定时转换为第一个绑定类。

让我们考虑一种打印任何给定数组内容的方法：

```java
public static <E> void printArray(E[] array) {
    for (E element : array) {
        System.out.printf("%s ", element);
    }
}
```

编译后，编译器将类型参数E替换为Object：

```java
public static void printArray(Object[] array) {
    for (Object element : array) {
        System.out.printf("%s ", element);
    }
}
```

对于绑定方法类型参数：

```java
public static <E extends Comparable<E>> void printArray(E[] array) {
    for (E element : array) {
        System.out.printf("%s ", element);
    }
}
```

我们将擦除类型参数E并替换为Comparable：

```java
public static void printArray(Comparable[] array) {
    for (Comparable element : array) {
        System.out.printf("%s ", element);
    }
}
```

## 4. 边缘情况

在类型擦除过程中的某个时候，编译器会创建一个合成方法来区分相似的方法。这些可能来自扩展相同的第一个绑定类的方法签名。

让我们创建一个新类来扩展我们之前的Stack实现。请注意，这是指我们在**3.1节**中创建的Stack类，而不是java.util.Stack。

```java
public class IntegerStack extends Stack<Integer> {

    public IntegerStack(int capacity) {
        super(capacity);
    }

    public void push(Integer value) {
        super.push(value);
    }
}
```

现在让我们看看下面的代码：

```java
IntegerStack integerStack = new IntegerStack(5);
Stack stack = integerStack;
stack.push("Hello");
Integer data = integerStack.pop();
```

类型擦除后，我们有：

```java
IntegerStack integerStack = new IntegerStack(5);
Stack stack = (IntegerStack) integerStack;
stack.push("Hello");
Integer data = (String) integerStack.pop();
```

请注意我们如何在IntegerStack上push字符串-因为IntegerStack从父类Stack继承了push(Object)。这当然是不正确的-因为它应该是一个整数，因为integerStack是Stack<Integer\>类型。

因此，毫不奇怪，尝试pop一个String并分配给一个Integer会导致编译器在push期间插入的强制转换中产生ClassCastException。

### 4.1 桥接方法

为了解决上述边缘情况，编译器有时会创建一个桥接方法。这是Java编译器在编译扩展参数化类或实现参数化接口的类或接口时创建的合成方法，其中方法签名可能略有不同或不明确。

在我们上面的示例中，Java编译器通过确保IntegerStack的push(Integer)方法和Stack的push(Object)方法之间没有方法签名不匹配来在擦除后保留泛型类型的多态性。

因此，编译器在这里创建了一个桥接方法：

```java
public class IntegerStack extends Stack {
    // Bridge method generated by the compiler

    public void push(Object value) {
        push((Integer) value);
    }

    public void push(Integer value) {
        super.push(value);
    }
}
```

因此，Stack类的push方法在类型擦除后委托给IntegerStack类的原始push方法。

## 5. 总结

在本教程中，我们通过类型参数变量和方法中的示例讨论了类型擦除的概念。

你可以阅读有关这些概念的更多信息：

-   [Java语言规范：类型擦除](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6)
-   [Java泛型基础](https://www.baeldung.com/java-generics)