## 1. 概述

有时我们需要测试数字中的二进制数字是否已设置。这可能是因为我们将数字用作一组标志，其中每个数字代表一个特定的布尔值。

在本教程中，我们将探讨从整数值(例如byte、short、char、int和long)中获取特定位置位的不同方法。

## 2. 测试特定位

最常见的情况之一是我们想要使用[位掩码](https://www.baeldung.com/java-bitmasking)测试整数值的特定位。

例如，让我们检查字节值中是否设置了第三位：

```java
byte val1 = 0b0110_0100;
byte mask = 0b0000_0100;
boolean isSet1 = (val1 & mask) > 0;
assertTrue(isSet1);
```

这里测试二进制数01100100以查看第三位–00000100是否通过使用[按位AND](https://www.baeldung.com/java-bitwise-operators)设置。结果大于零，所以它是。我们还可以测试它是否未设置：

```java
byte val2 = 0b0110_0010;
boolean isSet2 = (val2 & mask) > 0;
assertFalse(isSet2);
```

此示例基于字节数字类型，我们可以轻松地将其扩展为short、char、int和long值。

在此解决方案中，我们对位掩码进行了硬编码。如果我们想推广解决方案以检查数字中的任何位怎么办？

## 3. 使用移位运算符

在开始之前，我们先定义一个32位int中位位置的索引范围。最左边的位索引为31，最右边的位索引为0。这是因为我们的数字从最高有效位到最低有效位。例如，如果我们使用64位长数字，最左边的位就是63。

### 3.1 左移遮罩

我们可以通过取值1并使用左移运算符将其移动到正确的位置来生成位掩码：

```java
int val = 0b0110_0100;
int pos = 2;
int mask = 1 << pos;
boolean isSet = (val & mask) > 0;

assertTrue(isSet);
```

这里我们将pos设置为2，尽管它可以是我们数字中的任何有效位位置。然后，我们使用左移运算符(<<)生成我们的位掩码。最后，我们在val和mask之间进行按位与(&)运算。

如果结果大于零，则表示目标位已设置。

### 3.2 左移值

此外，还有另一种方法可以解决这个问题。

我们可以在要测试的值上使用左移运算符，而不是构造位掩码。与其使用位掩码过滤值，我们还可以移动其内容，使感兴趣的位位于最左边的位置。

然后我们需要做的就是检查最左边的位是否已设置。由于有符号整数表示为[二进制补码](https://www.baeldung.com/cs/two-complement)，我们可以通过测试结果移位数是否为负来测试前导数字是否为1。

```java
int val = 0b0110_0100;
int pos = 2;
boolean isSet = ((val << (31 - pos)) < 0);

assertTrue(isSet);
```

上面的pos是2，最左边的位置是31，所以我们用31减去pos，就是29，然后把原值左移29位，得到一个新的值。在这个新值中，有趣的位在最左边的位置。最后，我们检查新值是否小于零。

### 3.3 右移值

同样，我们可以使用右移运算符来测试一个整数值。将整数值的目标位移动到最右边的位置并使用位掩码1后，我们可以检查结果是否等于1：

```java
int val = 0b0110_0100;
int pos = 2;
boolean isSet = ((val >> pos) & 1) == 1;

assertTrue(isSet);
```

## 4. 优化按位解

在我们可能需要大量执行这些计算的情况下，我们可能希望优化我们的解决方案以使用最少数量的CPU指令。

让我们看一下左移解决方案的重写，这可能有助于我们实现这一目标。它基于按位运算通常比算术运算更快的假设：

```java
boolean isSet = ((val << (~pos & 31)) < 0);
```

我们应该注意到核心思想没有改变。只是代码的写法略有不同：我们使用(~pos&31)来替代之前的(31-pos)表达式。

为什么这两个表达式具有相同的效果？我们可以推导出这个过程：

```java
(31 - pos) = (31 - pos) & 31
            = (31 + (-pos)) & 31
            = (31 & 31) + ((-pos) & 31)
            = (31 & 31) + ((~pos + 1) & 31)
            = (31 & 31) + (~pos & 31) + (1 & 31)
            = ((31 + 1) & 31) + (~pos & 31)
            = (32 & 31) + (~pos & 31)
            = 0 + (~pos & 31)
            = (~pos & 31)
```

在本节开头，我们提到最左边的位置是31，最右边的位置是0，所以(31-pos)应该是正数或零。如果我们在(31–pos)和31之间进行按位与(&)运算，结果保持不变。然后，我们一步一步来。最后，我们得到(~pos&31)表达式。

在这个过程中，还有一件事需要解释：(-pos)是如何转化为(~pos+1)的？要获得[整数的二进制补码负符号](https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html#whyworks)，我们可以执行[按位补](https://www.baeldung.com/java-bitwise-operators#4-bitwisecomplement-)码(~)运算，然后将结果加一。

更进一步，我们可以让代码更简洁一点：

```java
boolean isSet = ((val << ~pos) < 0);
```

在上面，我们省略了按位与(&)和31。那是因为JVM会为我们完成这项工作。一个int值是32位的，JVM保证它的有效移位范围在0到31之间。同样，一个long值是64位的，JVM也保证它的有效移位范围在0到63之间.

## 5. 使用大整数

虽然上述二进制数学对于内置数字类型来说计算效率最高，但我们可能需要检查超过64位的数字的位，或者可能希望代码更易于阅读。

BigInteger类可以解决这两个问题。它支持具有大量位的非常大的数字，并提供了一个testBit方法：

```java
int val = 0b0110_0100;
int pos = 2;
boolean isSet = BigInteger.valueOf(val).testBit(pos);

assertTrue(isSet);
```

## 6. 总结

在本教程中，我们了解了一些从整数值中获取特定位置位的常用方法。