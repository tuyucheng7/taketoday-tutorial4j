## 1. 概述

在本教程中，我们将了解Java复合运算符、它们的类型以及Java如何计算它们。

我们还将解释隐式转换的工作原理。

## 2. 复合赋值运算符

赋值运算符是一种二元运算符，它将右侧的结果分配给左侧的变量。最简单的是“=”赋值运算符：

```java
int x = 5;
```

此语句声明一个新变量x，为x赋值5并返回5。

复合赋值运算符是应用算术或按位运算并将运算值分配给左侧变量的较短方法。

例如，以下两个乘法语句是等价的，意味着a和b将具有相同的值：

```java
int a = 3, b = 3, c = -2;
a = a  c; // Simple assignment operator
b = c; // Compound assignment operator
```

重要的是要注意复合赋值运算符左侧的变量必须已经声明。换句话说，复合运算符不能用于声明新变量。

与“=”赋值运算符一样，复合运算符返回表达式的赋值结果：

```java
long x = 1;
long y = (x+=2);
```

x和y都将保持值3。

赋值(x+=2)做了两件事：首先，它将变量x的值加2，变成3；其次，它返回赋值的值，也是3。

## 3. 复合赋值运算符的种类

Java支持11种复合赋值运算符。我们可以将它们分组为算术运算符和按位运算符。

让我们来看看算术运算符和它们执行的操作：

-   递增：+=
-   递减：-=
-   乘法：=
-   除法：/=
-   模数：%=

然后，我们还有按位运算符：

-   AND，二进制：&=
-   异或，二进制：^=
-   包含或，二进制：|=
-   左移，二进制：<<=
-   右移，二进制：>>=
-   右移补零：>>>=

让我们看一下这些操作的几个示例：

```java
// Simple assignment
int x = 5; // x is 5

// Incrementation
x += 5; // x is 10

// Decrementation
x -= 2; // x is 8

// Multiplication
x = 2; // x is 16

// Modulus
x %= 3; // x is 1

// Binary AND
x &= 4; // x is 0

// Binary exclusive OR
x ^= 4; // x is 4

// Binary inclusive OR
x |= 8; // x is 12
```

正如我们在这里看到的，使用这些运算符的语法是一致的。

## 4. 复合赋值运算的评价

Java有两种评估复合操作的方法。

首先，当左侧操作数不是数组时，Java将按顺序：

1. 验证操作数是声明的变量
2. 保存左侧操作数的值
3. 评估右侧操作数
4. 按照复合运算符的指示执行二元运算
5. 将二元运算的结果转换为左侧变量的类型(隐式转换)
6. 将转换后的结果分配给左侧变量

接下来，当左侧操作数是数组时，要遵循的步骤有点不同：

1. 验证左侧的数组表达式，如果不正确则抛出NullPointerException或ArrayIndexOutOfBoundsException
2. 将数组元素保存在索引中
3. 评估右侧操作数
4. 检查选择的数组元素是原始类型还是引用类型，然后继续执行与第一个列表相同的步骤，就好像左边的操作数是一个变量一样。

如果评估的任何步骤失败，Java不会继续执行以下步骤。

让我们给出一些与对数组元素的这些操作的评估相关的示例：

```java
int[] numbers = null;

// Trying Incrementation
numbers[2] += 5;
```

正如我们所料，这将抛出NullPointerException。

但是，如果我们为数组分配一个初始值：

```java
int[] numbers = {0, 1};

// Trying Incrementation
numbers[2] += 5;
```

我们会摆脱NullPointerException，但我们仍然会得到ArrayIndexOutOfBoundsException，因为使用的索引不正确。

如果我们修复它，操作将成功完成：

```java
int[] numbers = {0, 1};

// Incrementation
numbers[1] += 5; // x is now 6
```

最后，x变量在赋值结束时将为6。

## 5. 隐式转换

复合运算符有用的原因之一是它们不仅提供了更短的操作方式，而且还隐式转换变量。

形式上，复合赋值表达式的形式：

E1开=E2

相当于：

E1–(T)(E1在E2上)

其中T是E1的类型。

让我们考虑以下示例：

```java
long number = 10;
int i = number;
i = i  number; // Does not compile
```

让我们回顾一下为什么最后一行不能编译。

Java自动将较小的数据类型提升为较大的数据类型，当它们一起在一个操作中时，但在尝试从较大的类型转换为较小的类型时会抛出错误。

因此，首先，i将被提升为long，然后乘法将得出结果10L。long结果将分配给i，它是一个int，这将引发错误。

这可以通过显式转换来修复：

```java
i = (int) i  number;
```

Java复合赋值运算符在这种情况下是完美的，因为它们进行隐式转换：

```java
i = number;
```

该语句工作得很好，将乘法结果转换为int并将值分配给左侧变量i。

## 6. 总结

在本文中，我们研究了Java中的复合运算符，并给出了一些示例和它们的不同类型。我们解释了Java如何评估这些操作。

最后，我们还回顾了隐式转换，这是这些速记运算符有用的原因之一。