## 1. 概述

通常在我们的应用程序中，我们需要能够同时做多件事。我们可以通过多种方式实现这一点，但其中的关键是以某种形式实现多任务处理。

**多任务意味着同时运行多个任务，其中每个任务都在执行其工作**。这些任务通常同时运行，读取和写入相同的内存并与相同的资源交互，但做不同的事情。

## 2. 本机(原生)线程

**在Java中实现多任务的标准方法是使用线程**。操作系统通常支持线程，我们将在这个级别工作的线程称为“本机线程”。

操作系统具有一些我们的应用程序通常无法使用的线程能力，这仅仅是因为它与底层硬件的距离更近。这意味着执行本机线程通常效率更高。这些线程直接映射到计算机CPU上的执行线程-操作系统管理线程到CPU核心的映射。

Java中的标准线程模型涵盖所有JVM语言，使用本机线程。自Java 1.2以来一直如此，并且无论运行JVM的底层系统如何都是这种情况。

**这意味着无论何时我们使用Java中的任何标准线程机制，我们都在使用本机线程**。这包括java.lang.Thread、java.util.concurrent.Executor、java.util.concurrent.ExecutorService等等。

## 3. 绿色线程

在软件工程中，**本机线程的一种替代方法是绿色线程**。这是我们使用线程的地方，但它们并不直接映射到操作系统线程。相反，底层架构管理线程本身并管理它们如何映射到操作系统线程。

**通常这是通过运行多个本机线程然后将绿色线程分配到这些本机线程上执行来实现的**。然后系统可以选择在任何给定时间哪些绿色线程处于活动状态，以及它们在哪些本机线程上处于活动状态。

这听起来很复杂，确实如此。但这是我们通常不需要关心的并发症。底层架构负责所有这些，我们可以像使用本机线程模型一样使用它。

那我们为什么要这样做呢？本机线程运行起来非常高效，但启动和停止它们的成本很高。绿色线程有助于避免这种成本并为架构提供更大的灵活性。如果我们使用的是运行时间相对较长的线程，那么本机线程是非常高效的。**对于非常短暂的工作，启动它们的成本可能超过使用它们的好处**。在这些情况下，绿色线程可以变得更有效率。

不幸的是，**Java没有对绿色线程的内置支持**。

非常早期的Java版本使用绿色线程而不是本机线程作为标准线程模型。这在Java 1.2中发生了变化，此后JVM级别不再支持它。

在库中实现绿色线程也具有挑战性，因为它们需要非常低级别的支持才能正常运行。因此，常用的替代品是纤程。

## 4. 纤程

**纤程是多线程的另一种形式，类似于绿色线程**。在这两种情况下，我们都没有使用本机线程，而是使用随时运行的底层系统控件。绿色线程和纤程之间的最大区别在于控制级别，特别是谁在控制。

绿色线程是抢占式多任务处理的一种形式。这意味着底层架构完全负责决定在任何给定时间执行哪些线程。

这意味着线程的所有常见问题都适用，我们对线程执行的顺序一无所知，或者哪些线程将同时执行。这也意味着底层系统需要能够随时暂停和重新启动我们的代码，可能是在方法甚至语句的中间。

**相反，纤程是协作多任务处理的一种形式，这意味着正在运行的线程将继续运行，直到它发出可以屈服于另一个线程的信号**。这意味着我们有责任让纤程相互合作。这使我们可以直接控制纤程何时可以暂停执行，而不是由系统为我们决定。

这也意味着我们需要以一种允许这样做的方式编写代码。否则，它将不起作用。如果我们的代码没有任何中断点，那么我们还不如根本不使用纤程。

Java目前没有对纤程的内置支持。有一些库可以将其引入我们的应用程序，包括但不限于：

### 4.1 Quasar

**[Quasar](https://www.baeldung.com/kotlin-quasar)是一个Java库，可以很好地与纯Java和Kotlin配合使用，并且有一个替代版本可以与Clojure配合使用**。

它的工作原理是有一个需要与应用程序一起运行的Java代理，该代理负责管理纤程并确保它们正确地协同工作。使用Java代理意味着不需要特殊的构建步骤。

Quasar还需要Java 11才能正常工作，因此可能会限制可以使用它的应用程序。旧版本可以在Java 8上使用，但没有得到积极支持。

### 4.2 Kilim

**Kilim是一个Java库，它提供与Quasar非常相似的功能，但通过使用字节码编织而不是Java代理来实现**。这意味着它可以在更多地方工作，但它使构建过程更加复杂。

Kilim适用于Java 7及更高版本，即使在无法使用Java代理的情况下也能正常工作。例如，如果另一个已经用于检测或监控。

### 4.3 Loom

**[Project Loom](https://www.baeldung.com/openjdk-project-loom)最开始是OpenJDK项目的一项实验，旨在将纤程添加到JVM本身，而不是作为附加库**。这将为我们提供纤程优于线程的优势。通过直接在JVM上实现它，可以帮助避免Java代理和字节码编织引入的复杂性。

Project Loom目前没有发布时间表，但我们现在可以下载抢先体验二进制文件，看看进展如何。但是，由于现在还为时过早，因此对于任何生产代码，我们需要小心依赖它。

## 5. 协程

协程是线程和纤程的替代方案。**我们可以将协程视为没有任何形式的调度的纤程**。我们的代码直接执行此操作，而不是由底层系统随时决定执行哪些任务。

通常，我们编写协程，以便它们在流程的特定点产生。这些可以看作是我们函数中的暂停点，它将停止工作并可能输出一些中间结果。当我们执行yield时，我们将停止，直到调用代码出于某种原因决定重新启动我们。**这意味着我们的调用代码控制着何时运行**。

Kotlin在其标准库中内置了对协程的原生支持。如果需要，我们还可以使用其他几个Java库来实现它们。

## 6. 总结

我们已经在我们的代码中看到了多种不同的多任务替代方案，从传统的本机线程到一些非常轻量级的替代方案。为什么不在下次应用程序需要并发时尝试一下呢？